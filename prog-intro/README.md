# Тесты к курсу «Введение в программирование»

## Домашнее задание 13. Обработка ошибок (см. решение в "Парадигмах программирования")

Условие:

1.  Добавьте в программу, вычисляющую выражения, обработку ошибок, в том числе:
    *   ошибки разбора выражений;
    *   ошибки вычисления выражений.
2.  Для выражения `1000000*x*x*x*x*x/(x-1)` вывод программы должен иметь следующий вид:
    
    x       f
    0       0
    1       division by zero
    2       32000000
    3       121500000
    4       341333333
    5       overflow
    6       overflow
    7       overflow
    8       overflow
    9       overflow
    10      overflow
                
    
    Результат `division by zero` (`overflow`) означает, что в процессе вычисления произошло деление на ноль (переполнение).
3.  При выполнении задания следует обратить внимание на дизайн и обработку исключений.
4.  Человеко-читаемые сообщения об ошибках должны выводиться на консоль.
5.  Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).

Модификации
 * *Base*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        `TripleParser`
    * Классы `CheckedAdd`, `CheckedSubtract`, `CheckedMultiply`,
        `CheckedDivide` и `CheckedNegate` должны реализовывать интерфейс
        `TripleExpression`
    * Нельзя использовать типы `long` и `double`
    * Нельзя использовать методы классов `Math` и `StrictMath`
 * *SetClear* (34-37)
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `set` – установка бита, `2 set 3` равно 10;
        * `clear` – сброс бита, `10 clear 3` равно 2.
 * *Count* (32, 33, 36, 37)
    * Дополнительно реализуйте унарную операцию
      `count` – число установленных битов, `count -5` равно 31.
 * *GcdLcm* (38, 39)
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `gcd` – НОД, `2 gcd -3` равно 1;
        * `lcm` – НОК, `2 lcm -3` равно -6.
 * *Reverse* (38, 39)
    * Дополнительно реализуйте унарную операцию
      `reverse` – число с переставленными цифрами, `reverse -12345` равно `-54321`.
 * *PowLog10* (36-39)
    * Дополнительно реализуйте унарные операции:
        * `log10` – логарифм по уснованию 10, `log10 1000` равно 3;
        * `pow10` – 10 в степени, `pow10 4` равно 10000.


## Домашнее задание 12. Разбор выражений

Условие:

1.  Доработайте предыдущее домашнее задание, так что бы выражение строилось по записи вида
    
    x \* (x - 2)\*x + 1
    
2.  В записи выражения могут встречаться:
    *   бинарные операции: умножение `*`, деление `/`, сложение `+` и вычитание `-`;
    *   унарный минус `-`;
    *   переменные `x`, `y` и `z`;
    *   целочисленные константы в десятичной системе счисления, помещающиеся в 32-битный знаковый целочисленный тип;
    *   круглые скобки для явного обозначения приоритета операций;
    *   произвольное число пробельных символов в любом месте, не влияющем на однозначность понимания формулы (например, между операцией и переменной, но не внутри констант).
3.  Приоритет операций, начиная с наивысшего
    1.  унарный минус;
    2.  умножение и деление;
    3.  сложение и вычитание.
4.  Разбор выражений рекомендуется производить [методом рекурсивного спуска](https://web.archive.org/web/20230529010307/https://ru.wikibooks.org/wiki/%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D0%BE%D0%B3%D0%BE_%D1%81%D0%BF%D1%83%D1%81%D0%BA%D0%B0).
    *   Алгоритм должен работать за линейное время.
    *   Лексический анализ (токенизация) не требуется.

Модификации
 * *Base*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        `TripleParser`
    * Результат разбора должен реализовывать интерфейс
        `TripleExpression`
 * *SetClear* (34 - 37)
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `set` – установка бита, `2 set 3` равно 10;
        * `clear` – сброс бита, `10 clear 3` равно 2.
 * *Count* (32, 33, 36, 37)
    * Дополнительно реализуйте унарную операцию
      `count` – число установленных битов, `count -5` равно 31.
 * *GcdLcm* (38, 39)
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `gcd` – НОД, `2 gcd -3` равно 1;
        * `lcm` – НОК, `2 lcm -3` равно -6.
 * *Reverse* (38, 39)
    * Дополнительно реализуйте унарную операцию
      `reverse` – число с переставленными цифрами, `reverse -12345` равно `-54321`.


## Домашнее задание 11. Выражения

Условие:

1.  Разработайте классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide` для вычисления выражений с одной переменной в типе `int` (интерфейс `Expression`).
2.  Классы должны позволять составлять выражения вида
    
    new Subtract(
        new Multiply(
            new Const(2),
            new Variable("x")
        ),
        new Const(3)
    ).evaluate(5)
                
    
    При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра методу `evaluate`. Таким образом, результатом вычисления приведенного примера должно стать число 7.
3.  Метод `toString` должен выдавать запись выражения в полноскобочной форме. Например
    
    new Subtract(
        new Multiply(
            new Const(2),
            new Variable("x")
        ),
        new Const(3)
    ).toString()
                
    
    должен выдавать `((2 * x) - 3)`.
4.  _Сложный вариант._ Метод `toMiniString` (интерфейс `ToMiniString`) должен выдавать выражение с минимальным числом скобок. Например
    
    new Subtract(
        new Multiply(
            new Const(2),
            new Variable("x")
        ),
        new Const(3)
    ).toMiniString()
                
    
    должен выдавать `2 * x - 3`.
5.  Реализуйте метод `equals`, проверяющий, что два выражения совпадают. Например,
    
    new Multiply(new Const(2), new Variable("x"))
        .equals(new Multiply(new Const(2), new Variable("x")))
                
    
    должно выдавать `true`, а
    
    new Multiply(new Const(2), new Variable("x"))
        .equals(new Multiply(new Variable("x"), new Const(2)))
                
    
    должно выдавать `false`.
6.  Для тестирования программы должен быть создан класс `Main`, который вычисляет значение выражения `x2−2x+1`, для `x`, заданного в командной строке.
7.  При выполнении задания следует обратить внимание на:
    *   Выделение общего интерфейса создаваемых классов.
    *   Выделение абстрактного базового класса для бинарных операций.

Модификации
 * *Base*
    * Реализуйте интерфейс `Expression`
 * *Triple* (32-39)
    * Дополнительно реализуйте поддержку выражений с тремя переменными: `x`, `y` и `z`.
    * Интерфейс `TripleExpression`.
 * *Double* (36-39)
    * Дополнительно реализуйте вычисления в типе `double`.
    * Интерфейс `DoubleExpression`.


## Домашнее задание 10. Игра m,n,k

Условие:

В этом домашнем задании вы можете пользоваться кодом, написанным на лекции. Он есть на сайте курса.

1.  Реализуйте [игру m,n,k](https://web.archive.org/web/20230529010307/https://en.wikipedia.org/wiki/M,n,k-game) (_k_ в ряд на доске _m×n_).
2.  Добавьте обработку ошибок ввода пользователя. В случае ошибочного хода пользователь должен иметь возможность сделать другой ход.
3.  Добавьте обработку ошибок игроков. В случае ошибки игрок автоматически проигрывает.
4.  _Простая версия_. Доска может производить обработку хода за _O(nmk)_.
5.  _Сложная версия_.
    *   Доска должна производить обработку хода (проверку корректности, изменение состояния и определение результата) за _O(k)_.
    *   Предотвратите жульничество: у игрока не должно быть возможности достать `Board` из `Position`.
6.  _Бонусная версия_. Реализуйте `Winner` — игрок, который выигрывает всегда, когда это возможно (против любого соперника).

Тесты не предусмотрены. Решение должно находиться в пакете `game`.

Модификации
 * *Матчи* (32 - 35)
    * Добавьте поддержку матчей: последовательность игр до указанного числа побед.
    * Стороны в матче должны меняться каждую игру.
 * *Дополнительные ходы* (34, 35)
    * Если в результате хода игрока на доске появляется новая последовательность
      из 4+ одинаковых символов, то он делает дополнительный ход.
    * Игрок может сделать несколько дополнительных ходов подряд.
 * *Турнир* (36 - 39)
    * Добавьте поддержку кругового турнира для нескольких участников.
    * В рамках кругового турнира каждый с каждым должен сыграть две партии,
      по одной каждым цветом.
    * Выведите таблицу очков по схеме:
        * 3 очка за победу;
        * 1 очко за ничью;
        * 0 очков за поражение.
 * *Препятствия* (36 - 39)
    * Добавьте поддержку препятствий — клеток, в которые запрещено делать ходы.
    * В качестве примера, сделайте доску размером <em>11×11</em>,
      у которой клетки на диагоналях запрещены.
 * *Multiplayer* (38, 39)
    * Добавьте поддержку значков `-` и `|`;
    * Добавьте возможность игры для 3 и 4 игроков.


## Домашнее задание 9. Markdown to HTML

Условие:

1.  Разработайте конвертер из [Markdown](https://web.archive.org/web/20230529010307/https://ru.wikipedia.org/wiki/Markdown)\-разметки в [HTML](https://web.archive.org/web/20230529010307/https://ru.wikipedia.org/wiki/HTML).
2.  Конвертер должен поддерживать следующие возможности:
    1.  Абзацы текста разделяются пустыми строками.
    2.  Элементы строчной разметки: выделение (`*` или `_`), сильное выделение (`**` или `__`), зачеркивание (`--`), код (`` ` ``)
    3.  Заголовки (`#` \* уровень заголовка)
3.  Конвертер должен называться `md2html.Md2Html` и принимать два аргумента: название входного файла с Markdown-разметкой и название выходного файла c HTML-разметкой. Оба файла должны иметь кодировку UTF-8.
4.  При выполнении этого ДЗ можно повторно использовать код ДЗ `markup`.
5.  Конвертер может хранить исходные и сконвертированные данные в памяти, в том числе, одновременно.
6.  Пример
    *   Входной файл
        
        \# Заголовок первого уровня
        
        ## Второго
        
        ### Третьего ## уровня
        
        #### Четвертого
        # Все еще четвертого
        
        Этот абзац текста,
        содержит две строки.
        
            # Может показаться, что это заголовок.
        Но нет, это абзац начинающийся с \`#\`.
        
        #И это не заголовок.
        
        ###### Заголовки могут быть многострочными
        (и с пропуском заголовков предыдущих уровней)
        
        Мы все любим \*выделять\* текст \_разными\_ способами.
        \*\*Сильное выделение\*\*, используется гораздо реже,
        но \_\_почему бы и нет\_\_?
        Немного --зачеркивания-- еще ни кому не вредило.
        Код представляется элементом \`code\`.
        
        Обратите внимание, как экранируются специальные
        HTML-символы, такие как \`<\`, \`>\` и \`&\`.
        
        Знаете ли вы, что в Markdown, одиночные \* и \_
        не означают выделение?
        Они так же могут быть заэкранированы
        при помощи обратного слэша: \\\*.
        
        
        
        Лишние пустые строки должны игнорироваться.
        
        Любите ли вы \*вложеные \_\_выделения\_\_\* так,
        как \_\_--люблю--\_\_ их я?
                    
        
    *   Выходной файл
        
        <h1>Заголовок первого уровня</h1>
        <h2>Второго</h2>
        <h3>Третьего ## уровня</h3>
        <h4>Четвертого
        # Все еще четвертого</h4>
        <p>Этот абзац текста,
        содержит две строки.</p>
        <p>    # Может показаться, что это заголовок.
        Но нет, это абзац начинающийся с <code>#</code>.</p>
        <p>#И это не заголовок.</p>
        <h6>Заголовки могут быть многострочными
        (и с пропуском заголовков предыдущих уровней)</h6>
        <p>Мы все любим <em>выделять</em> текст <em>разными</em> способами.
        <strong>Сильное выделение</strong>, используется гораздо реже,
        но <strong>почему бы и нет</strong>?
        Немного <s>зачеркивания</s> еще ни кому не вредило.
        Код представляется элементом <code>code</code>.</p>
        <p>Обратите внимание, как экранируются специальные
        HTML-символы, такие как <code>&lt;</code>, <code>&gt;</code> и <code>&amp;</code>.</p>
        <p>Знаете ли вы, что в Markdown, одиночные \* и \_
        не означают выделение?
        Они так же могут быть заэкранированы
        при помощи обратного слэша: \*.</p>
        <p>Лишние пустые строки должны игнорироваться.</p>
        <p>Любите ли вы <em>вложеные <strong>выделения</strong></em> так,
        как <strong><s>люблю</s></strong> их я?</p>
                    
        
    *   Реальная разметка
        
        Заголовок первого уровня
        ========================
        
        Второго
        -------
        
        ### Третьего ## уровня
        
        #### Четвертого # Все еще четвертого
        
        Этот абзац текста, содержит две строки.
        
        \# Может показаться, что это заголовок. Но нет, это абзац начинающийся с `#`.
        
        #И это не заголовок.
        
        ###### Заголовки могут быть многострочными (и с пропуском заголовков предыдущих уровней)
        
        Мы все любим _выделять_ текст _разными_ способами. **Сильное выделение**, используется гораздо реже, но **почему бы и нет**? Немного зачеркивания еще ни кому не вредило. Код представляется элементом `code`.
        
        Обратите внимание, как экранируются специальные HTML-символы, такие как `<`, `>` и `&`.
        
        Знаете ли вы, что в Markdown, одиночные \* и \_ не означают выделение? Они так же могут быть заэкранированы при помощи обратного слэша: \*.
        
        Лишние пустые строки должны игнорироваться.
        
        Любите ли вы _вложеные **выделения**_ так, как **люблю** их я?

Модификации
 * *Базовая*
 * *Link* (38, 39)
    * Добавьте поддержку ```[ссылок с _выделением_](https://kgeorgiy.info)```:
        ```<a href='https://kgeorgiy.info'>ссылок с <em>выделением</em></a>```
 * *Image* (36, 37)
    * Добавьте поддержку ```![картинок](https://www.ifmo.ru/images/menu/small/p10.jpg)```:
        ```<img alt='картинок' src='https://www.ifmo.ru/images/menu/small/p10.jpg'>```
 * *Underline* (34, 35)
    * Добавьте поддержку `++подчеркивания++`: `<u>подчеркивания</u>`
 * *Mark* (32, 33)
    * Добавьте поддержку `~выделения цветом~`: `<mark>выделения цветом</mark>`

## Домашнее задание 8. Контест

Условие:

1.  Решите как можно больше задач Чемпионата северо-запада России по программированию 2019.
2.  Материалы соревнования:
    *   [PCMS](https://web.archive.org/web/20230529010307/https://pcms.itmo.ru/): Java. North-Western Russia Regional Contest - 2019
    *   [Условия задач](https://web.archive.org/web/20230529010307/https://nerc.itmo.ru/archive/2019/northern/nwrrc-2019-statements.pdf)
    *   [Разбор задач](https://web.archive.org/web/20230529010307/https://nerc.itmo.ru/archive/2019/northern/nwrrc-2019-tutorials.pdf)
3.  Задачи для решения
    
    Задача
    
    Тема
    
    Сложность
    
    A.
    
    Accurate Movement
    
    Формула
    
    5
    
    B.
    
    Bad Treap
    
    Циклы
    
    10
    
    C.
    
    Cross-Stitch
    
    Графы
    
    40
    
    D.
    
    Double Palindrome
    
    Массивы
    
    40
    
    E.
    
    Equidistant
    
    Деревья
    
    30
    
    H.
    
    High Load Database
    
    Массивы
    
    20
    
    I.
    
    Ideal Pyramid
    
    Циклы
    
    15
    
    J.
    
    Just the Last Digit
    
    Матрицы
    
    20
    
    K.
    
    King’s Children
    
    Массивы
    
    40
    
    M.
    
    Managing Difficulties
    
    Коллекции
    
    10
    
4.  Рекомендуемое время выполнения задания: 3 часа

5.  Решение находится в папке qf-solutions

6.  [Условия задач контеста](https://neerc.ifmo.ru/archive/2019/northern/nwrrc-2019-statements.pdf) 

## Домашнее задание 7. Разметка

Условие:

1.  Разработайте набор классов для текстовой разметки.
2.  Класс `Paragraph` может содержать произвольное число других элементов разметки и текстовых элементов.
3.  Класс `Text` – текстовый элемент.
4.  Классы разметки `Emphasis`, `Strong`, `Strikeout` – выделение, сильное выделение и зачеркивание. Элементы разметки могут содержать произвольное число других элементов разметки и текстовых элементов.
5.  Все классы должны реализовывать метод `toMarkdown([StringBuilder](https://web.archive.org/web/20230529010307/https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html))`, который должен генерировать [Markdown](https://web.archive.org/web/20230529010307/https://ru.wikipedia.org/wiki/Markdown)\-разметку по следующим правилам:
    1.  текстовые элементы выводятся как есть;
    2.  выделенный текст окружается символами '`*`';
    3.  сильно выделенный текст окружается символами '`__`';
    4.  зачеркнутый текст окружается символами '`~`'.
6.  Следующий код должен успешно компилироваться:
    
        Paragraph paragraph = new Paragraph(List.of(
            new Strong(List.of(
                new Text("1"),
                new Strikeout(List.of(
                    new Text("2"),
                    new Emphasis(List.of(
                        new Text("3"),
                        new Text("4")
                    )),
                    new Text("5")
                )),
                new Text("6")
            ))
        ));
    
    Вызов `paragraph.toMarkdown(new StringBuilder())` должен заполнять переданный `StringBuilder` следующим содержимым:
    
        \_\_1~2\*34\*5~6\_\_
    
7.  Разработанные классы должны находиться в пакете `markup`.

Модификации
 * *Base*
 * *HtmlList* (36, 37)
    * Дополнительно реализуйте метод `toHtml`, генерирующий HTML-разметку:
      * выделеный текст окружается тегом `em`;
      * сильно выделеный текст окружается тегом `strong`;
      * зачеркнутый текст окружается тегом `s`.
    * Добавьте поддержку:
      * Нумерованных списков (класс `OrderedList`, тег `ol`): последовательность элементов
      * Ненумерованных списков (класс `UnorderedList`, тег `ul`): последовательность элементов
      * Элементов списка (класс `ListItem`, тег `li`): последовательность абзацев и списков
    * Для новых классов поддержка Markdown не требуется
 * *TexList* (38, 39)
    * Дополнительно реализуйте метод `toTex`, генерирующий TeX-разметку:
      * выделеный текст заключается в `\emph{` и `}`;
      * сильно выделеный текст заключается в `\textbf{` и `}`;
      * зачеркнутый текст заключается в `\textst{` и `}`.
    * Добавьте поддержку:
      * Нумерованных списков (класс `OrderedList`, окружение `enumerate`): последовательность элементов
      * Ненумерованных списков (класс `UnorderedList`, окружение `itemize`): последовательность элементов
      * Элементов списка (класс `ListItem`, тег `\item`: последовательность абзацев и списков
    * Для новых классов поддержка Markdown не требуется
 * *Tex* (34, 35)
    * Дополнительно реализуйте метод `toTex`, генерирующий TeX-разметку:
      * выделеный текст заключается в `\emph{` и `}`;
      * сильно выделеный текст заключается в `\textbf{` и `}`;
      * зачеркнутый текст заключается в `\textst{` и `}`.
 * *Html* (32, 33)
    * Дополнительно реализуйте метод `toHtml`, генерирующий HTML-разметку:
      * выделеный текст окружается тегом `em`;
      * сильно выделеный текст окружается тегом `strong`;
      * зачеркнутый текст окружается тегом `s`.


## Домашнее задание 6. Подсчет слов++

Условие:

1.  Разработайте класс `Wspp`, который будет подсчитывать статистику встречаемости слов во входном файле.
2.  Словом называется непрерывная последовательность букв, апострофов и тире (Unicode category Punctuation, Dash). Для подсчета статистики, слова приводятся к нижнему регистру.
3.  Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова должна быть выведена одна строка, содержащая слово, число его вхождений во входной файл и номера вхождений этого слова среди всех слов во входном файле.
4.  Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
5.  Программа должна работать за линейное от размера входного файла время.
6.  Для реализации программы используйте Collections Framework.
7.  _Сложный вариант._ Реализуйте и примените класс `IntList`, компактно хранящий список целых чисел.
8.  Примеры работы программы:
    
    Входной файл
    
    Выходной файл
    
        To be, or not to be, that is the question:
    
        to 2 1 5
        be 2 2 6
        or 1 3
        not 1 4
        that 1 7
        is 1 8
        the 1 9
        question 1 10
    
        Monday's child is fair of face.
        Tuesday's child is full of grace.
    
        monday's 1 1
        child 2 2 8
        is 2 3 9
        fair 1 4
        of 2 5 11
        face 1 6
        tuesday's 1 7
        full 1 10
        grace 1 12
    
        Шалтай-Болтай
        Сидел на стене.
        Шалтай-Болтай
        Свалился во сне.
    
        шалтай-болтай 2 1 5
        сидел 1 2
        на 1 3
        стене 1 4
        свалился 1 6
        во 1 7
        сне 1 8 

Модификации
 * *Base*
    * Класс должен иметь имя `Wspp`
 * *LastL* (36, 37)
    * Вместо номеров вхождений во всем файле надо указывать
      только последнее вхождение в каждой строке.
    * Класс должен иметь имя `WsppLastL`
 * *CountLastL* (38, 39)
    * В выходном файле слова должны быть упорядочены по возрастанию числа
      вхождений, а при равном числе вхождений – по порядку первого вхождения
      во входном файле.
    * Вместо номеров вхождений во всем файле надо указывать
      только последнее вхождение в каждой строке.
    * Класс должен иметь имя `WsppCountLastL`
 * *CountPosition* (34, 35)
    * В выходном файле слова должны быть упорядочены по возрастанию числа
      вхождений, а при равном числе вхождений – по порядку первого вхождения
      во входном файле.
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер в строке>`
    * Класс должен иметь имя `WsppCountPosition`
 * *Position* (32, 33)
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер в строке>`
    * Класс должен иметь имя `WsppPosition`


## Домашнее задание 5. Свой сканнер

Условие:

1.  Реализуйте свой аналог класса [Scanner](https://web.archive.org/web/20230529010307/https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html) на основе [Reader](https://web.archive.org/web/20230529010307/https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Reader.html).
2.  Примените разработанный `Scanner` для решения задания «Реверс».
3.  Примените разработанный `Scanner` для решения задания «Статистика слов».
4.  Нужно использовать блочное чтение. Код, управляющий чтением, должен быть общим.
5.  _Сложный вариант_. Код, выделяющий числа и слова, должен быть общим.
6.  Обратите внимание на:
    *   Обработку ошибок.
    *   На слова/числа, пересекающие границы блоков, особенно — больше одного раза.

Модификации
 * *Base*
 * *OctDec* (36, 37)
    * На вход подаются десятичные и восьмиричные числа
    * Восьмиричные числа имеют суффикс `o`
    * Класс должен иметь имя `ReverseOctDec`
 * *OctAbc* (38, 39)
    * На вход подаются десятичные и восьмиричные числа
    * Восьмиричные числа имеют суффикс `o`
    * Десятичные числа могут быть записаны буквами:
      нулю соответствует буква `a`, единице – `b` и так далее
    * Класс должен иметь имя `ReverseOctAbc`
 * *Oct* (32, 33)
    * Во вводе и выводе используются числа в восьмеричной системе счисления
    * Класс должен иметь имя `ReverseOct`
 * *Abc* (34, 35)
    * Во вводе и выводе используются числа, записаные буквами:
      нулю соответствует буква `a`, единице – `b` и так далее
    * Класс должен иметь имя `ReverseAbc`


## Домашнее задание 4. Подсчет слов

Условие:

1.  Разработайте класс `WordStatInput`, подсчитывающий статистику встречаемости слов во входном файле.
2.  Словом называется непрерывная последовательность букв, апострофов (`'`) и дефисов (Unicode category [Punctuation, Dash](https://web.archive.org/web/20230529010307/https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#DASH_PUNCTUATION)). Для подсчета статистики слова приводятся к нижнему регистру.
3.  Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова должна быть выведена одна строка, содержащая слово и число его вхождений во входном файле.
4.  Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
5.  Примеры работы программы:
    
    Входной файл
    
    Выходной файл
    
    To be, or not to be, that is the question:
    
    to 2
    be 2
    or 1
    not 1
    that 1
    is 1
    the 1
    question 1
    
    Monday's child is fair of face.
    Tuesday's child is full of grace.
    
    monday's 1
    child 2
    is 2
    fair 1
    of 2
    face 1
    tuesday's 1
    full 1
    grace 1
    
    Шалтай-Болтай
    Сидел на стене.
    Шалтай-Болтай
    Свалился во сне.
    
    шалтай-болтай 2
    сидел 1
    на 1
    стене 1
    свалился 1
    во 1
    сне 1

Модификации
 * *Base*
    * Класс должен иметь имя `WordStatInput`
 * *WordsPrefix* (36, 37)
    * Выходной файл должен содержать все различные префиксы длины 3
      слов, встречающихся во входном файле,
      в лексикографическом порядке.
      Слова длины меньшей 3 используются как есть.
    * Класс должен иметь имя `WordStatWordsPrefix`
 * *WordsShingles* (38, 39)
    * Выходной файл должен содержать все различные подстроки длины 3
      слов, встречающихся во входном файле,
      в лексикографическом порядке.
      Слова длины меньшей 3 используются как есть.
    * Класс должен иметь имя `WordStatWordsShingles`
 * *Words* (32, 33)
    * В выходном файле слова должны быть упорядочены
      в лексикографическом порядке
    * Класс должен иметь имя `WordStatWords`
 * *WordsSuffix* (34, 35)
    * Выходной файл должен содержать все различные суффиксы длины 3
      слов встречающихся во входном файле,
      в лексикографическом порядке.
      Слова длины меньшей 3 используются как есть.
    * Класс должен иметь имя `WordStatWordsSuffix`


## Домашнее задание 3. Реверс

Условие:

1.  Разработайте класс `Reverse`, читающий числа из [стандартного ввода](https://web.archive.org/web/20230529010307/https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.html#in), и выводящий их на [стандартный вывод](https://web.archive.org/web/20230529010307/https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.html#out) в обратном порядке.
2.  В каждой строке входа содержится некоторое количество целых чисел (возможно ноль). Числа разделены пробелами. Каждое число помещается в тип `int`.
3.  Порядок строк в выходе должен быть обратным по сравнению с порядком строк во входе. Порядок чисел в каждой строке также должен быть обратным к порядку чисел во входе.
4.  Вход содержит не более 106 чисел и строк.
5.  Для чтения чисел используйте класс [Scanner](https://web.archive.org/web/20230529010307/https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html).
6.  Примеры работы программы:
    
    Ввод
    
    Вывод
    
    1 2
    3
    
    3
    2 1
    
    3
    2 1
    
    1 2
    3
    
    1
    
    2 -3
    
    \-3 2
    
    1
    
    1     2
    3     4
    
    4 3
    2 1 


Модификации
 * *Base*
 * *Sum* (36, 37)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите сумму чисел
      в его столбце и строке
    * Класс должен иметь имя `ReverseSum`
 * *Avg* (38, 39)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите среднее из чисел в его столбце и строке
    * Класс должен иметь имя `ReverseAvg`
 * *Memory* (36-39)
    * Пусть _M_ – объём памяти, необходимый для сохранения ввода      в двумерном массиве `int` минимального размера.
      Ваша программа должна использовать не более 4_M_ + 1024 байт памяти.
    * Накладные расходы на запуск вашей программы JVM не учитываются.
 * *Even* (32, 33)
    * Выведите (в реверсивном порядке) только четные числа
    * Класс должен иметь имя `ReverseEven`
 * *Transpose* (34, 35)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      выведите ее в транспонированном виде
    * Класс должен иметь имя `ReverseTranspose`


## Домашнее задание 2. Сумма чисел

1.  Разработайте класс `Sum`, который при запуске из командной строки будет складывать переданные в качестве аргументов целые числа и выводить их сумму на консоль.
2.  Примеры запуска программы:
    
    `java Sum 1 2 3`
    
    Результат: 6
    
    `java Sum 1 2 -3`
    
    Результат: 0
    
    `java Sum "1 2 3"`
    
    Результат: 6
    
    `java Sum "1 2" " 3"`
    
    Результат: 6
    
    `java Sum " "`
    
    Результат: 0
    
    Аргументы могут содержать:
    *   цифры;
    *   знаки `+` и `-`;
    *   произвольные [пробельные символы](https://web.archive.org/web/20230529010307/https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#isWhitespace(char)).
3.  При выполнении задания можно считать, что для представления входных данных и промежуточных результатов достаточен тип `int`.
4.  Перед выполнением задания ознакомьтесь с документацией к классам [String](https://web.archive.org/web/20230529010307/https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html) и [Integer](https://web.archive.org/web/20230529010307/https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Integer.html).
5.  Для отладочного вывода используйте [System.err](https://web.archive.org/web/20230529010307/https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.html#err), тогда он будет игнорироваться проверяющей программой.

Модификации
 * *Octal* (36, 37)
    * Восьмеричные числа имеют суффикс `o`
    * Класс должен иметь имя `SumOctal`
 * *LongOctal* (38, 39)
    * Входные данные являются 64-битными целыми числами
    * восьмеричные числа имеют суффикс `o`
    * Класс должен иметь имя `SumLongOctal`
 * *Double* (34, 35)
    * Входные данные являются 64-битными числами с формате с плавающей точкой
    * Класс должен иметь имя `SumDouble`
 * *Float* (32, 33)
    * Входные данные являются 32-битными числами с формате с плавающей точкой
    * Класс должен иметь имя `SumFloat`