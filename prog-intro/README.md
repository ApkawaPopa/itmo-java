# Тесты к курсу «Введение в программирование»

## Домашнее задание 13. Обработка ошибок (см. решение в "Парадигмах программирования")

Модификации
 * *Base*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        `TripleParser`
    * Классы `CheckedAdd`, `CheckedSubtract`, `CheckedMultiply`,
        `CheckedDivide` и `CheckedNegate` должны реализовывать интерфейс
        `TripleExpression`
    * Нельзя использовать типы `long` и `double`
    * Нельзя использовать методы классов `Math` и `StrictMath`
 * *SetClear* (34-37)
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `set` – установка бита, `2 set 3` равно 10;
        * `clear` – сброс бита, `10 clear 3` равно 2.
 * *Count* (32, 33, 36, 37)
    * Дополнительно реализуйте унарную операцию
      `count` – число установленных битов, `count -5` равно 31.
 * *GcdLcm* (38, 39)
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `gcd` – НОД, `2 gcd -3` равно 1;
        * `lcm` – НОК, `2 lcm -3` равно -6.
 * *Reverse* (38, 39)
    * Дополнительно реализуйте унарную операцию
      `reverse` – число с переставленными цифрами, `reverse -12345` равно `-54321`.
 * *PowLog10* (36-39)
    * Дополнительно реализуйте унарные операции:
        * `log10` – логарифм по уснованию 10, `log10 1000` равно 3;
        * `pow10` – 10 в степени, `pow10 4` равно 10000.


## Домашнее задание 12. Разбор выражений

Модификации
 * *Base*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        `TripleParser`
    * Результат разбора должен реализовывать интерфейс
        `TripleExpression`
 * *SetClear* (34 - 37)
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `set` – установка бита, `2 set 3` равно 10;
        * `clear` – сброс бита, `10 clear 3` равно 2.
 * *Count* (32, 33, 36, 37)
    * Дополнительно реализуйте унарную операцию
      `count` – число установленных битов, `count -5` равно 31.
 * *GcdLcm* (38, 39)
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `gcd` – НОД, `2 gcd -3` равно 1;
        * `lcm` – НОК, `2 lcm -3` равно -6.
 * *Reverse* (38, 39)
    * Дополнительно реализуйте унарную операцию
      `reverse` – число с переставленными цифрами, `reverse -12345` равно `-54321`.


## Домашнее задание 11. Выражения

Модификации
 * *Base*
    * Реализуйте интерфейс `Expression`
 * *Triple* (32-39)
    * Дополнительно реализуйте поддержку выражений с тремя переменными: `x`, `y` и `z`.
    * Интерфейс `TripleExpression`.
 * *Double* (36-39)
    * Дополнительно реализуйте вычисления в типе `double`.
    * Интерфейс `DoubleExpression`.


## Домашнее задание 10. Игра m,n,k

Тесты не предусмотрены. Решение должно находиться в пакете `game`.

Модификации
 * *Матчи* (32 - 35)
    * Добавьте поддержку матчей: последовательность игр до указанного числа побед.
    * Стороны в матче должны меняться каждую игру.
 * *Дополнительные ходы* (34, 35)
    * Если в результате хода игрока на доске появляется новая последовательность
      из 4+ одинаковых символов, то он делает дополнительный ход.
    * Игрок может сделать несколько дополнительных ходов подряд.
 * *Турнир* (36 - 39)
    * Добавьте поддержку кругового турнира для нескольких участников.
    * В рамках кругового турнира каждый с каждым должен сыграть две партии,
      по одной каждым цветом.
    * Выведите таблицу очков по схеме:
        * 3 очка за победу;
        * 1 очко за ничью;
        * 0 очков за поражение.
 * *Препятствия* (36 - 39)
    * Добавьте поддержку препятствий — клеток, в которые запрещено делать ходы.
    * В качестве примера, сделайте доску размером <em>11×11</em>,
      у которой клетки на диагоналях запрещены.
 * *Multiplayer* (38, 39)
    * Добавьте поддержку значков `-` и `|`;
    * Добавьте возможность игры для 3 и 4 игроков.


## Домашнее задание 9. Markdown to HTML

Модификации
 * *Базовая*
 * *Link* (38, 39)
    * Добавьте поддержку ```[ссылок с _выделением_](https://kgeorgiy.info)```:
        ```<a href='https://kgeorgiy.info'>ссылок с <em>выделением</em></a>```
 * *Image* (36, 37)
    * Добавьте поддержку ```![картинок](https://www.ifmo.ru/images/menu/small/p10.jpg)```:
        ```<img alt='картинок' src='https://www.ifmo.ru/images/menu/small/p10.jpg'>```
 * *Underline* (34, 35)
    * Добавьте поддержку `++подчеркивания++`: `<u>подчеркивания</u>`
 * *Mark* (32, 33)
    * Добавьте поддержку `~выделения цветом~`: `<mark>выделения цветом</mark>`


## Домашнее задание 7. Разметка

Условие:
* Разработайте набор классов для текстовой разметки.
* Класс Paragraph может содержать произвольное число других элементов разметки и текстовых элементов.
* Класс Text – текстовый элемент.
* Классы разметки Emphasis, Strong, Strikeout – выделение, сильное выделение и зачеркивание. Элементы разметки могут содержать произвольное число других элементов разметки и текстовых элементов.
* Все классы должны реализовывать метод toMarkdown(StringBuilder), который должен генерировать Markdown-разметку по следующим правилам:
    текстовые элементы выводятся как есть;
    выделенный текст окружается символами '*';
    сильно выделенный текст окружается символами '__';
    зачеркнутый текст окружается символами '~'.
* Следующий код должен успешно компилироваться:  
    Paragraph paragraph = new Paragraph(List.of(  
        new Strong(List.of(  
            new Text("1"),  
            new Strikeout(List.of(  
                new Text("2"),  
                new Emphasis(List.of(  
                    new Text("3"),  
                    new Text("4")  
                )),  
                new Text("5")  
            )),  
            new Text("6")  
        ))  
    ));  
    Вызов paragraph.toMarkdown(new StringBuilder()) должен заполнять переданный StringBuilder следующим содержимым:  
        __1~2*34*5~6__  
* Разработанные классы должны находиться в пакете markup.  

Модификации
 * *Base*
 * *HtmlList* (36, 37)
    * Дополнительно реализуйте метод `toHtml`, генерирующий HTML-разметку:
      * выделеный текст окружается тегом `em`;
      * сильно выделеный текст окружается тегом `strong`;
      * зачеркнутый текст окружается тегом `s`.
    * Добавьте поддержку:
      * Нумерованных списков (класс `OrderedList`, тег `ol`): последовательность элементов
      * Ненумерованных списков (класс `UnorderedList`, тег `ul`): последовательность элементов
      * Элементов списка (класс `ListItem`, тег `li`): последовательность абзацев и списков
    * Для новых классов поддержка Markdown не требуется
 * *TexList* (38, 39)
    * Дополнительно реализуйте метод `toTex`, генерирующий TeX-разметку:
      * выделеный текст заключается в `\emph{` и `}`;
      * сильно выделеный текст заключается в `\textbf{` и `}`;
      * зачеркнутый текст заключается в `\textst{` и `}`.
    * Добавьте поддержку:
      * Нумерованных списков (класс `OrderedList`, окружение `enumerate`): последовательность элементов
      * Ненумерованных списков (класс `UnorderedList`, окружение `itemize`): последовательность элементов
      * Элементов списка (класс `ListItem`, тег `\item`: последовательность абзацев и списков
    * Для новых классов поддержка Markdown не требуется
 * *Tex* (34, 35)
    * Дополнительно реализуйте метод `toTex`, генерирующий TeX-разметку:
      * выделеный текст заключается в `\emph{` и `}`;
      * сильно выделеный текст заключается в `\textbf{` и `}`;
      * зачеркнутый текст заключается в `\textst{` и `}`.
 * *Html* (32, 33)
    * Дополнительно реализуйте метод `toHtml`, генерирующий HTML-разметку:
      * выделеный текст окружается тегом `em`;
      * сильно выделеный текст окружается тегом `strong`;
      * зачеркнутый текст окружается тегом `s`.


## Домашнее задание 6. Подсчет слов++

Условие:
* Разработайте класс Wspp, который будет подсчитывать статистику встречаемости слов во входном файле.
* Словом называется непрерывная последовательность букв, апострофов и тире (Unicode category Punctuation, Dash). Для подсчета статистики, слова приводятся к нижнему регистру.
* Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова должна быть выведена одна строка, содержащая слово, число его вхождений во входной файл и номера вхождений этого слова среди всех слов во входном файле.
* Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
* Программа должна работать за линейное от размера входного файла время.
* Для реализации программы используйте Collections Framework.
* Сложный вариант. Реализуйте и примените класс IntList, компактно хранящий список целых чисел.
* Примеры работы программы:
    Входной файл                                    Выходной файл  
    To be, or not to be, that is the question:      to 2 1 5  
                                                    be 2 2 6  
                                                    or 1 3  
                                                    not 1 4  
                                                    that 1 7  
                                                    is 1 8  
                                                    the 1 9  
                                                    question 1 10  


    Monday's child is fair of face.                 monday's 1 1  
    Tuesday's child is full of grace.               child 2 2 8     
                                                    is 2 3 9  
                                                    fair 1 4  
                                                    of 2 5 11  
                                                    face 1 6  
                                                    tuesday's 1 7  
                                                    full 1 10  
                                                    grace 1 12  


    Шалтай-Болтай                                   шалтай-болтай 2 1 5  
    Сидел на стене.                                 сидел 1 2  
    Шалтай-Болтай                                   на 1 3  
    Свалился во сне.                                стене 1 4  
                                                    свалился 1 6  
                                                    во 1 7  
                                                    сне 1 8  

Модификации
 * *Base*
    * Класс должен иметь имя `Wspp`
 * *LastL* (36, 37)
    * Вместо номеров вхождений во всем файле надо указывать
      только последнее вхождение в каждой строке.
    * Класс должен иметь имя `WsppLastL`
 * *CountLastL* (38, 39)
    * В выходном файле слова должны быть упорядочены по возрастанию числа
      вхождений, а при равном числе вхождений – по порядку первого вхождения
      во входном файле.
    * Вместо номеров вхождений во всем файле надо указывать
      только последнее вхождение в каждой строке.
    * Класс должен иметь имя `WsppCountLastL`
 * *CountPosition* (34, 35)
    * В выходном файле слова должны быть упорядочены по возрастанию числа
      вхождений, а при равном числе вхождений – по порядку первого вхождения
      во входном файле.
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер в строке>`
    * Класс должен иметь имя `WsppCountPosition`
 * *Position* (32, 33)
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер в строке>`
    * Класс должен иметь имя `WsppPosition`


## Домашнее задание 5. Свой сканнер

Условие:
* Реализуйте свой аналог класса Scanner на основе Reader.
* Примените разработанный Scanner для решения задания «Реверс».
* Примените разработанный Scanner для решения задания «Статистика слов».
* Нужно использовать блочное чтение. Код, управляющий чтением, должен быть общим.
* Сложный вариант. Код, выделяющий числа и слова, должен быть общим.
* Обратите внимание на:
    * Обработку ошибок.
    * На слова/числа, пересекающие границы блоков, особенно — больше одного раза.

Модификации
 * *Base*
 * *OctDec* (36, 37)
    * На вход подаются десятичные и восьмиричные числа
    * Восьмиричные числа имеют суффикс `o`
    * Класс должен иметь имя `ReverseOctDec`
 * *OctAbc* (38, 39)
    * На вход подаются десятичные и восьмиричные числа
    * Восьмиричные числа имеют суффикс `o`
    * Десятичные числа могут быть записаны буквами:
      нулю соответствует буква `a`, единице – `b` и так далее
    * Класс должен иметь имя `ReverseOctAbc`
 * *Oct* (32, 33)
    * Во вводе и выводе используются числа в восьмеричной системе счисления
    * Класс должен иметь имя `ReverseOct`
 * *Abc* (34, 35)
    * Во вводе и выводе используются числа, записаные буквами:
      нулю соответствует буква `a`, единице – `b` и так далее
    * Класс должен иметь имя `ReverseAbc`


## Домашнее задание 4. Подсчет слов

Условие:
* Разработайте класс WordStatInput, подсчитывающий статистику встречаемости слов во входном файле.
* Словом называется непрерывная последовательность букв, апострофов (') и дефисов (Unicode category Punctuation, Dash). Для подсчета статистики слова приводятся к нижнему регистру.
* Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова должна быть выведена одна строка, содержащая слово и число его вхождений во входном файле.
* Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
* Примеры работы программы:
    Входной файл                                    Выходной файл  
    To be, or not to be, that is the question:      to 2  
                                                    be 2  
                                                    or 1  
                                                    not 1  
                                                    that 1  
                                                    is 1  
                                                    the 1  
                                                    question 1  


    Monday's child is fair of face.                 monday's 1  
    Tuesday's child is full of grace.               child 2  
                                                    is 2  
                                                    fair 1  
                                                    of 2  
                                                    face 1  
                                                    tuesday's 1  
                                                    full 1  
                                                    grace 1  


    Шалтай-Болтай                                   шалтай-болтай 2  
    Сидел на стене.                                 сидел 1  
    Шалтай-Болтай                                   на 1  
    Свалился во сне.                                стене 1  
                                                    свалился 1  
                                                    во 1  
                                                    сне 1  

Модификации
 * *Base*
    * Класс должен иметь имя `WordStatInput`
 * *WordsPrefix* (36, 37)
    * Выходной файл должен содержать все различные префиксы длины 3
      слов, встречающихся во входном файле,
      в лексикографическом порядке.
      Слова длины меньшей 3 используются как есть.
    * Класс должен иметь имя `WordStatWordsPrefix`
 * *WordsShingles* (38, 39)
    * Выходной файл должен содержать все различные подстроки длины 3
      слов, встречающихся во входном файле,
      в лексикографическом порядке.
      Слова длины меньшей 3 используются как есть.
    * Класс должен иметь имя `WordStatWordsShingles`
 * *Words* (32, 33)
    * В выходном файле слова должны быть упорядочены
      в лексикографическом порядке
    * Класс должен иметь имя `WordStatWords`
 * *WordsSuffix* (34, 35)
    * Выходной файл должен содержать все различные суффиксы длины 3
      слов встречающихся во входном файле,
      в лексикографическом порядке.
      Слова длины меньшей 3 используются как есть.
    * Класс должен иметь имя `WordStatWordsSuffix`


## Домашнее задание 3. Реверс

Условие:
* Разработайте класс Reverse, читающий числа из стандартного ввода, и выводящий их на стандартный вывод в обратном порядке.
* В каждой строке входа содержится некоторое количество целых чисел (возможно ноль). Числа разделены пробелами. Каждое число помещается в тип int.
* Порядок строк в выходе должен быть обратным по сравнению с порядком строк во входе. Порядок чисел в каждой строке также должен быть обратным к порядку чисел во входе.
* Вход содержит не более 106 чисел и строк.
* Для чтения чисел используйте класс Scanner.
* Примеры работы программы:  
    Ввод        Вывод  
    
    1 2         3  
    3           2 1  


    3           1 2  
    2 1         3  


    1           -3 2  

    2 -3        1  


    1     2     4 3  
    3     4     2 1  


Модификации
 * *Base*
 * *Sum* (36, 37)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите сумму чисел
      в его столбце и строке
    * Класс должен иметь имя `ReverseSum`
 * *Avg* (38, 39)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите среднее из чисел в его столбце и строке
    * Класс должен иметь имя `ReverseAvg`
 * *Memory* (36-39)
    * Пусть _M_ – объём памяти, необходимый для сохранения ввода      в двумерном массиве `int` минимального размера.
      Ваша программа должна использовать не более 4_M_ + 1024 байт памяти.
    * Накладные расходы на запуск вашей программы JVM не учитываются.
 * *Even* (32, 33)
    * Выведите (в реверсивном порядке) только четные числа
    * Класс должен иметь имя `ReverseEven`
 * *Transpose* (34, 35)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      выведите ее в транспонированном виде
    * Класс должен иметь имя `ReverseTranspose`


## Домашнее задание 2. Сумма чисел

Условие: 
* Разработайте класс Sum, который при запуске из командной строки будет складывать переданные в качестве аргументов целые числа и выводить их сумму на консоль.
* Примеры запуска программы:  
    java Sum 1 2 3  
    Результат: 6  
    java Sum 1 2 -3  
    Результат: 0  
    java Sum "1 2 3"  
    Результат: 6  
    java Sum "1 2" " 3"  
    Результат: 6  
    java Sum " "  
    Результат: 0  
    Аргументы могут содержать:
    * цифры;
    * знаки + и -;
    * произвольные пробельные символы.
* При выполнении задания можно считать, что для представления входных данных и промежуточных результатов достаточен тип int.
* Перед выполнением задания ознакомьтесь с документацией к классам String и Integer.
* Для отладочного вывода используйте System.err, тогда он будет игнорироваться проверяющей программой.

Модификации
 * *Octal* (36, 37)
    * Восьмеричные числа имеют суффикс `o`
    * Класс должен иметь имя `SumOctal`
 * *LongOctal* (38, 39)
    * Входные данные являются 64-битными целыми числами
    * восьмеричные числа имеют суффикс `o`
    * Класс должен иметь имя `SumLongOctal`
 * *Double* (34, 35)
    * Входные данные являются 64-битными числами с формате с плавающей точкой
    * Класс должен иметь имя `SumDouble`
 * *Float* (32, 33)
    * Входные данные являются 32-битными числами с формате с плавающей точкой
    * Класс должен иметь имя `SumFloat`
